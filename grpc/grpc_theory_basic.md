## Конспект
что такое RPC - remote procedure calls. Это способ вызвать функцию и получить результат выполнения в другой программе
Функция может быть вызвана как на этом же сервере, так и на любом другом, который доступен с сети
процедура схематично следующая
клиент вызывает функцию (процедуру) на сервере, сообщая какую именно функцию нужно вызвать и с какими аргументами
сервер получает функцию (процедуру), выполняет ее и возвращает результат
клиент получает результат выполнения функции (процедуры)

**gRPC** это именно фреймворк для выполнения RPC. gRPC реализован на протоколе HTTP/2 для транспортировки и protobuf как язык определения модели
HTTP/2 - переработанный протокол HTTP/1.1
Основные отличия
- запрос и ответ происходит в бинарном формате
- мультиплексирование ответов в одном соединении
- сжатие заголовков
Protobuf проект для сериализации данных (так же как и json или xml), но он быстрее, меньше и проще
Основные понятия
- IDL язык. Строгой типизации
- поддерживает генерацию кода
- Runtime-библиотеки - для сериализации данных

### **Типы RPC в gRPC**

1. **Unary RPC** (Один запрос — один ответ)
- **Описание**: Клиент отправляет запрос на сервер и получает один ответ. Это наиболее простой и распространённый тип RPC.
-  **Похоже на**: Обычный вызов функции (синхронный или асинхронный).
-  **Пример**:
	- Клиент запрашивает данные пользователя по `user_id`, сервер возвращает объект пользователя.
```python
# Unary RPC вызов 
response = stub.GetUserInfo(UserRequest(id=123)) 
print(response.name)
```

2. **Server streaming RPC** (Серверный поток)
- **Описание**: Клиент отправляет запрос, сервер отвечает **последовательностью сообщений**. Клиент читает сообщения в потоке до тех пор, пока сервер не завершит передачу.
- **Похоже на**: Сервер отдаёт данные по частям, как в REST API с пагинацией, но здесь поток непрерывен.
- **Пример**:
	- Клиент запрашивает список товаров, сервер возвращает их по одному в виде потока.
- **Особенности**: gRPC гарантирует **упорядоченность сообщений** в потоке.
```python
for product in stub.GetProductList(ProductRequest(category="electronics")):
	print(product.name)

```

3. **Client streaming RPC** (Клиентский поток)
- **Описание**: Клиент отправляет **последовательность сообщений** серверу. После завершения передачи данных сервер обрабатывает их и возвращает один ответ.
- **Похоже на**: Клиент отправляет данные порциями (например, данные из файла) и получает ответ после обработки.
- **Пример**: Клиент загружает список транзакций на сервер, сервер возвращает итоговый отчёт.
- **Особенности**:  gRPC гарантирует **упорядоченность сообщений** от клиента.
```python
stream = stub.UploadTransactions()
for transaction in transactions:
    stream.send(Transaction(amount=transaction.amount, date=transaction.date))
response = stream.close_and_receive()
print(response.status)
```

4. **Bi-directional streaming RPC** (Двунаправленный поток)
- **Описание**: Клиент и сервер одновременно отправляют и принимают сообщения в независимых потоках. Чтение и запись **не зависят друг от друга**, что даёт большую гибкость.
- **Похоже на**: Постоянное соединение, как в WebSockets, где обе стороны могут отправлять данные в любой момент.
- **Пример**: Видеоконференция, где клиент и сервер обмениваются потоками данных в реальном времени.
- **Особенности**: Упорядоченность гарантируется **в пределах одного потока**, но не между клиентом и сервером.
```python
responses = stub.Chat()
for response in responses:
    print(f"Server: {response.message}")
    responses.send(ChatMessage(message="Hello, server!"))
```

### Как реализуются методы (жизненный цикл RPC)
1. Unary RPC
- Клиент формирует запрос (с данными, метаданными и deadline, если требуется). Этот запрос отправляется на сервер.
- Сервер принимает сообщение от клиента (Имя метода, Данные запроса, Дополнительные параметры). Сервер может вернуть метаданные сразу, либо подождать получения полного запроса, обработать данные и отправить их
- Сервер обрабатывает запрос и формирует ответ. 
- Сервер отправляет ответ клиенту со статусом обработки. Ок если данные обработались, или ошибку

2. Server streaming RPC
- Клиент формирует запрос (с данными, метаданными и deadline, если требуется). Этот запрос отправляется на сервер.
- Сервер обрабатывает запрос и начинает отправлять данные в потоке. Вместо одного ответа сервер возвращает **поток сообщений**, который клиент может читать по мере поступления данных.
- Клиент читает поток сообщений. Он может читать их по мере поступления до тех пор, пока сервер не завершит поток.
- Сервер завершает поток с финальным статусом. Статус `OK`, если всё прошло успешно, или ошибка

3. Client streaming RPC
- Клиент отправляет поток сообщений на сервер и ожидает ответ от сервера
- Сервер обрабатывает сообщения, читая их из потока.
- Сервер отправляет **один** ответ клиенту со статусом обработки. Ок если данные обработались, или ошибку

4. Bidirectional streaming RPC
- Инициация запроса клиентом. Клиент инициирует соединение вызовом метода-заглушки с метаданными
- Ответ сервера метаданными сразу или после начала стриминга данных от клиента
- Обмен данными в потоках. Клиент начинает отправлять поток данных. Сервер читает этот поток и может немедленно начать отправлять свои сообщения или подождать завершения клиентского потока перед отправкой данных. Оба потока работают **независимо**.
- Закрытие потоков происходит в любой момент. Поток данных завершается, когда обе стороны закрыли свои потоки.

### Как описываются файлы protobuf
Протокол буфера описывается в файлах, с расширением .proto
Файлы Protobuf (`.proto`) - Это **контракт** между клиентом и сервером, который определяет: Какие данные передаются (структура сообщений). Какие методы доступны для вызова (сервисы).

### Какие преимущества у protobuf
- Компактное представление данных. Использует бинарный формат вместо текстового (например, JSON или XML).
- Быстрая сериализация и десериализация. Оптимизирован для высокой скорости работы.
- Многоязычная поддержка
- Обратная совместимость.
- Автоматическая генерация кода

### Когда protobuf не подходит
- Если объем данных большей (больше нескольких мегабайт), потому что protobuf загружает входящее сообщение в память
- Невозможность сравнить 2 сообщения без парсинга (сообщения отправляются в бинарном формате, нечитаемым человеком)
- Сообщения не сжимаются
- Не всегда подходит для инженерных задач
- Не возможность интерпретировать сообщение без файла `.proto`. Чтобы понять, что содержится в бинарном формате Protobuf, нужно знать его структуру, описанную в `.proto` файле.

### **Сводная таблица: Protobuf vs Альтернативы**

|**Критерий**|**Protobuf**|**Альтернатива**|
|---|---|---|
|**Обработка больших данных**|Не подходит|Потоковые данные (например, gRPC streaming).|
|**Сравнение сообщений**|Нужна десериализация|JSON или XML.|
|**Сжатие данных**|Не встроено|JSON с GZIP или просто GZIP.|
|**Инженерные задачи**|Ограниченные возможности|HDF5, Apache Arrow.|
|**Самодостаточность данных**|Нужен `.proto` файл|JSON или XML.|
