---
created_date: 18-10-2024
created_time: 16:46
tags: interview
---
### 1. **Что такое транзакция?**

Транзакция — это единица работы с базой данных, которая может состоять из одного или нескольких SQL-запросов, которые должны быть выполнены как одно целое. Транзакция либо полностью завершится успешно, либо все изменения будут откатаны (роль **атомарности** транзакций).

### 2. **Блокировки**

Когда транзакция начинает выполняться, база данных может накладывать **блокировки** на таблицы или строки. Эти блокировки нужны для обеспечения целостности данных и предотвращения "грязного чтения" или неконсистентного состояния данных.

- В зависимости от типа блокировки и уровня изоляции транзакции, может блокироваться только часть таблицы (строки) или вся таблица.
- Например, при обновлении записи может быть заблокирована только та строка, которая изменяется.

### 3. **Откат транзакции (rollback)**

Если в ходе выполнения транзакции возникает ошибка (например, ошибка валидации данных или нарушение уникальности), то транзакция будет откатана. Это значит, что **все изменения, выполненные в рамках транзакции**, будут отменены. База данных вернется в состояние, которое было **до начала транзакции**.

### 4. **Коммит (commit)**

Если все команды в транзакции выполнены успешно, то изменения будут **зафиксированы** в базе данных с помощью команды `COMMIT`. После этого они становятся видимыми для других транзакций и процессов.

### 5. **Уровни изоляции**

Транзакции могут выполняться на разных уровнях изоляции. В postgres:

- **READ COMMITTED** (используется по умолчанию)
- **REPEATABLE READ**
- **SERIALIZABLE**

## Пример

```sql
BEGIN;

INSERT INTO cars (car_name, brand_id, price) VALUES ('Model X', 1, 80000); 
UPDATE cars SET price = 85000 WHERE car_name = 'Model X';

COMMIT;
```

```sql
BEGIN;
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;

INSERT INTO cars (car_name, brand_id, price) VALUES ('Model X', 1, 80000); 
UPDATE cars SET price = 85000 WHERE car_name = 'Model X';

COMMIT;
---
ROLLBACK;
```

### Как внешние ключи поддерживают целостность данных?

Целостность данных означает, что все данные в базе остаются корректными и согласованными. Внешние ключи помогают в этом, предотвращая ситуации, когда таблицы содержат **несогласованные или "осиротевшие" данные**.

#### Основные способы поддержания целостности данных с помощью внешних ключей:

1. **Ограничение ссылочной целостности**: Это основной механизм. Внешние ключи не позволяют вставить в таблицу запись, которая ссылается на несуществующую запись в другой таблице. Например, ты не сможешь вставить заказ в таблицу `orders`, если в таблице `customers` нет клиента с соответствующим идентификатором.
    
2. **Ограничения при удалении или обновлении данных**: Внешний ключ может быть настроен так, чтобы определенным образом реагировать на удаление или обновление записи, на которую ссылаются другие записи. Эти реакции позволяют контролировать, что произойдет с данными, если родительская запись изменяется или удаляется.

### Что такое триггер?

**Триггер** — это специальная функция в базе данных, которая автоматически выполняется при определенных событиях (например, вставка, обновление или удаление данных в таблице). Триггеры помогают автоматизировать некоторые процессы, обеспечивать целостность данных и выполнять сложную бизнес-логику непосредственно на уровне базы данных.

### Пример
1. создаем функцию, которая будет вызываться при срабатывании триггера
```sql
CREATE OR REPLACE FUNCTION update_brand_last_update()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE brands
    SET last_update = NOW()
    WHERE brand_id = NEW.brand_id;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

2. Создаем триггер
```sql
CREATE TRIGGER car_insert_trigger
AFTER INSERT ON cars
FOR EACH ROW
EXECUTE FUNCTION update_brand_last_update();
```

3. Проверка работы
```sql
INSERT INTO brands (brand_name) VALUES ('BMW');

INSERT INTO cars (car_name, brand_id) VALUES ('BMW X5', 1);

```

### Как триггеры поддерживают целостность данных:

1. **Проверки перед выполнением операций**: Как в примере с проверкой существования бренда, триггеры могут предотвращать некорректные операции до того, как они произойдут.
    
2. **Автоматическое обновление связанных данных**: Как в примере с обновлением времени последнего изменения, триггеры могут автоматически поддерживать целостность данных между связанными таблицами.
    
3. **Логирование изменений**: Как в примере с логированием удалений, триггеры позволяют отслеживать изменения данных, что может быть полезно для аудита и контроля.

## Пример и проверка транзакций из примера на youtube

1. Создаем таблицу и добавляем несколько данных
```sql
CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    product_name VARCHAR(50),
    quantity INT
);

INSERT INTO products (product_name, quantity) VALUES ('Product A', 10), ('Product B', 20);
```

2. Тестируем **READ COMMITTED**
**Session 1**:
```sql
BEGIN;
SELECT * FROM products WHERE product_id = 1;
---
Product A | 10
```

**Session 2**
```sql
BEGIN;
UPDATE products SET quantity = 15 WHERE product_id = 1;
COMMIT;
```

**Session 1**
```sql
SELECT * FROM products WHERE product_id = 1;
---
Product A | 15
```

3. Тестируем **REPEATABLE READ**
**Session 1**
```sql
BEGIN;
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
SELECT * FROM products WHERE product_id = 1;
---
Product A | 15
```

**Session 2**
```sql
BEGIN;
UPDATE products SET quantity = 25 WHERE product_id = 1;
COMMIT;
```

**Session 1**
```sql
SELECT * FROM products WHERE product_id = 1;
---
Product A | 15
```

